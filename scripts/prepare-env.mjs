// scripts/prepare-env.mjs
// Generate a single root .env by merging files from /env based on a target runtime.
// No external deps. Cross-platform. Deterministic output.
//
// Default usage via predev hook: prepares "local" (dev) env automatically.
// Manual usage examples:
//   node scripts/prepare-env.mjs --env=local
//   node scripts/prepare-env.mjs --env=production
//   node scripts/prepare-env.mjs --env=supabase
//   node scripts/prepare-env.mjs --env=local --out=.env     (default)
//   node scripts/prepare-env.mjs --env=local --print        (stdout only)
//   node scripts/prepare-env.mjs --env=local --dry          (don’t write)
//
// Precedence: earlier files are base, later files override.
// Default mapping below covers common flows; add more if you like.
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { join, resolve } from 'node:path';

const args = Object.fromEntries(
	process.argv.slice(2).map((a) => {
		const [k, v] = a.split('=');
		return [k.replace(/^--/, ''), v ?? true];
	}),
);

const rootDir = resolve(__dirname, '..');
const envDir = join(rootDir, 'env');

// Accept CLI flag, ENV var, or default
const targetEnv =
	(typeof args.env === 'string' && args.env) || process.env.DEPLOYMENT_ENVIRONMENT || 'local';

const outFile = join(rootDir, (typeof args.out === 'string' && args.out) || '.env');
const DRY = !!args.dry;
const PRINT = !!args.print;

// ---- ENV FILE MAPPING (edit this list as your matrix grows) ----
const ENV_MATRIX = {
	production: ['.env.base', '.env.production'],
	development: ['.env.base', '.env.development'],
	supabase: ['.env.base', '.env.development', '.env.supabase', '.env.local'],
	local: ['.env.base', '.env.development', '.env.local'],
};

// Fallback rule if an unknown env is passed: base + specific
const filesForEnv = ENV_MATRIX[targetEnv] ?? ['.env.base', `.env.${targetEnv}`];

// ----------------- helpers -----------------
function parseEnv(content) {
	// Minimal .env parser supporting KEY=VAL, quotes, comments, blank lines.
	// Compatible with docker/prisma/next parsing expectations.
	const out = {};
	const lines = content.split(/\r?\n/);

	for (let raw of lines) {
		const line = raw.trim();
		if (!line || line.startsWith('#')) continue;

		// Allow "export KEY=VAL"
		const cleaned = line.startsWith('export ') ? line.slice(7).trim() : line;

		const eq = cleaned.indexOf('=');
		if (eq === -1) continue;
		const key = cleaned.slice(0, eq).trim();
		let val = cleaned.slice(eq + 1).trim();

		// Remove surrounding quotes if present
		if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
			val = val.slice(1, -1);
		}

		// Unescape simple \" and \n sequences
		val = val.replace(/\\n/g, '\n').replace(/\\"/g, '"');

		out[key] = val;
	}
	return out;
}

function loadEnvFile(filePath) {
	if (!existsSync(filePath)) return {};
	const src = readFileSync(filePath, 'utf8');
	return parseEnv(src);
}

function mergeEnvObjects(objs) {
	return objs.reduce((acc, cur) => Object.assign(acc, cur), {});
}

function needsQuoting(value) {
	// Keep values unquoted when possible (Prisma & Compose-friendly).
	// Quote only if spaces, #, or special chars are present.
	return /[\s#"'`$\\]/.test(value) || value === '';
}

function serializeEnv(obj, sources) {
	const keys = Object.keys(obj).sort((a, b) => a.localeCompare(b));

	const lines = [
		`# Auto-generated by scripts/prepare-env.mjs`,
		`# Target: ${targetEnv}`,
		`# Sources: ${sources.join(', ')}`,
		`# Do not edit this file manually.`,
	];

	for (const k of keys) {
		let v = String(obj[k] ?? '');
		// Normalize newlines to \n in file output
		v = v.replace(/\r\n/g, '\n');
		if (needsQuoting(v)) {
			const quoted = v.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
			lines.push(`${k}="${quoted}"`);
		} else {
			lines.push(`${k}=${v}`);
		}
	}
	lines.push(''); // trailing newline
	return lines.join('\n');
}

// ----------------- main -----------------
const sourceFiles = filesForEnv.map((f) => join(envDir, f));
const envObjs = sourceFiles.map(loadEnvFile);
const merged = mergeEnvObjects(envObjs);
const output = serializeEnv(merged, filesForEnv);

if (PRINT) {
	process.stdout.write(output);
} else if (!DRY) {
	writeFileSync(outFile, output);
	console.log(`✅ Wrote ${outFile} for env "${targetEnv}"`);
} else {
	console.log(`(dry-run) Would write ${outFile} for env "${targetEnv}"`);
}
