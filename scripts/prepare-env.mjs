// 'scripts/prepare-env.mjs'
//
// Generate a single root .env by merging files from /env based on a target runtime.
// No external deps. Cross-platform. Deterministic output.
//
// Default behavior: prepares "local" unless LR_TARGET_ENV is provided by the caller.
// Intended usage: called by 'scripts/dev.mjs' (wrapper) prior to launching Next.js.
//
// Manual usage examples (for inspection only):
//   node scripts/prepare-env.mjs --print        (stdout only)
//   node scripts/prepare-env.mjs --dry          (don’t write)
//   node scripts/prepare-env.mjs --out=.env     (custom output path)
//
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, join, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = resolve(__dirname, '..');
const envDir = join(rootDir, 'env');

// ---- Selection --------------------------------------------------------------
// Environment selection is *only* via LR_TARGET_ENV (injected by the dev wrapper).
// No CLI selection, no reading of generic shell env like dev_env/DEPLOYMENT_ENV.
const TARGET_RAW = (process.env.LR_TARGET_ENV && String(process.env.LR_TARGET_ENV)) || 'local';
const TARGET = TARGET_RAW.trim().toLowerCase();

// Single, simple rule: merge .env.base (optional) + .env.<target> (optional)
const candidateFiles = ['.env.base', `.env.${TARGET}`];

// ---- Lightweight arg parsing (only for output/visibility flow control) -----
const args = Object.fromEntries(
	process.argv.slice(2).map((a) => {
		const [k, v] = a.split('=');
		return [k.replace(/^--/, ''), v ?? true];
	}),
);
const DRY = !!args.dry;
const PRINT = !!args.print;
const outFile = join(rootDir, (typeof args.out === 'string' && args.out) || '.env');

// ----------------- helpers -----------------
function parseEnv(content) {
	// Minimal .env parser supporting KEY=VAL, quotes, comments, blank lines.
	// Compatible with docker/prisma/next parsing expectations.
	const out = {};
	const lines = content.split(/\r?\n/);

	for (let raw of lines) {
		const line = raw.trim();
		if (!line || line.startsWith('#')) continue;

		// Allow "export KEY=VAL"
		const cleaned = line.startsWith('export ') ? line.slice(7).trim() : line;

		const eq = cleaned.indexOf('=');
		if (eq === -1) continue;
		const key = cleaned.slice(0, eq).trim();
		let val = cleaned.slice(eq + 1).trim();

		// Remove surrounding quotes if present
		if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
			val = val.slice(1, -1);
		}

		// Unescape simple \" and \n sequences
		val = val.replace(/\\n/g, '\n').replace(/\\"/g, '"');

		out[key] = val;
	}
	return out;
}

function loadEnvFile(filePath) {
	if (!existsSync(filePath)) return { __missing__: true };
	const src = readFileSync(filePath, 'utf8');
	return parseEnv(src);
}

function mergeEnvObjects(objs) {
	return objs.reduce((acc, cur) => {
		if (cur && cur.__missing__) return acc;
		return Object.assign(acc, cur);
	}, {});
}

function needsQuoting(value) {
	// Keep values unquoted when possible (Prisma & Compose-friendly).
	// Quote only if spaces, #, or special chars are present.
	return /[\s#"'`$\\]/.test(value) || value === '';
}

function serializeEnv(obj, sources, targetName) {
	const keys = Object.keys(obj).sort((a, b) => a.localeCompare(b));

	const lines = [
		`# Auto-generated by scripts/prepare-env.mjs`,
		`# Target: ${targetName}`,
		`# Sources: ${sources.join(', ') || '(none found)'}`,
		`# Do not edit this file manually.`,
	];

	for (const k of keys) {
		let v = String(obj[k] ?? '');
		// Normalize newlines to \n in file output
		v = v.replace(/\r\n/g, '\n');
		if (needsQuoting(v)) {
			const quoted = v.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
			lines.push(`${k}="${quoted}"`);
		} else {
			lines.push(`${k}=${v}`);
		}
	}
	lines.push(''); // trailing newline
	return lines.join('\n');
}

// ----------------- main -----------------
try {
	const absPaths = candidateFiles.map((f) => join(envDir, f));
	const envObjs = absPaths.map(loadEnvFile);

	// Sources that actually exist (relative names)
	const existingSources = envObjs
		.map((obj, idx) => (obj && obj.__missing__ ? null : candidateFiles[idx]))
		.filter(Boolean);

	const merged = mergeEnvObjects(envObjs);
	const output = serializeEnv(merged, existingSources, TARGET);

	if (PRINT) {
		process.stdout.write(output);
	} else if (!DRY) {
		writeFileSync(outFile, output);
		console.log(
			`✅ Generated .env (Target: ${TARGET}; Sources: ${existingSources.join(', ') || 'none'})`,
		);
	} else {
		console.log(
			`(dry-run) Would generate .env (Target: ${TARGET}; Sources: ${existingSources.join(', ') || 'none'})`,
		);
	}
} catch (err) {
	console.error('❌ Failed to generate .env:', err?.message || err);
	process.exitCode = 1;
}
